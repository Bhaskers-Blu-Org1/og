/* Copyright (c) IBM Corporation 2016. All Rights Reserved.
 * Project name: Object Generator
 * This project is licensed under the Apache License 2.0, see LICENSE.
 */

package com.ibm.og.s3;

import com.ibm.og.api.Body;
import com.ibm.og.api.DataType;
import com.ibm.og.api.Method;
import com.ibm.og.api.Operation;
import com.ibm.og.api.Request;
import com.ibm.og.api.Response;
import com.ibm.og.http.Bodies;
import com.ibm.og.http.Credential;
import com.ibm.og.http.HttpRequest;
import com.ibm.og.http.Scheme;
import com.ibm.og.util.Context;
import com.ibm.og.util.Pair;

import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Supplier;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.google.common.eventbus.Subscribe;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * A supplier of multipart requests
 * 
 * @since 1.0
 */
public class MultipartRequestSupplier implements Supplier<Request> {
  private static final Logger _logger = LoggerFactory.getLogger(MultipartRequestSupplier.class);

  private static final Joiner.MapJoiner PARAM_JOINER = Joiner.on('&').withKeyValueSeparator("=");
  private final Function<Map<String, String>, String> id;
  private final Scheme scheme;
  private final Function<Map<String, String>, String> host;
  private final Integer port;
  private final String uriRoot;
  private final Function<Map<String, String>, String> container;
  private final Function<Map<String, String>, String> object;
  private final Function<Map<String, String>, Long> partSize;
  private final int targetSessions;
  private final Map<String, Function<Map<String, String>, String>> queryParameters;
  private final boolean trailingSlash;
  private final Map<String, Function<Map<String, String>, String>> headers;
  private final List<Function<Map<String, String>, String>> context;
  private final Function<Map<String, String>, Credential> credentials;
  private final Function<Map<String, String>, Body> body;
  private final boolean virtualHost;

  // constants
  private final int NO_PART = -1;
  private final String UPLOAD_ID = "uploadId";
  private final String PART_NUMBER = "partNumber";
  private final String UPLOADS = "uploads";

  private final Random randomNumber;
  // request lists and hashmap
  private final Map<String, MultipartInfo> multipartRequestMap;
  private final List<MultipartInfo> actionableMultipartSessions;
  private final List<MultipartInfo> blockedMultipartSessions;

  private AtomicInteger inProgressSessions;
  private Object lockActionableMultipartSessions;
  private Object lockBlockedMultipartSessions;
  private Object lockBlockingWaitNotify;

  /**
   * Creates an instance
   *
   * @param id a supplier of ids to uniquely identify each request that is generated by this
   *        instance
   * @param scheme
   * @param host
   * @param port
   * @param uriRoot the base url part e.g. /soh/, /, /s3/
   * @param container
   * @param object
   * @param queryParameters static query parameters to all requests
   * @param trailingSlash whether or not to add a trailing slash to the url
   * @param headers headers to add to each request; header values may be dynamic
   * @param context request metadata to be sent with the created request
   * @param credentials username/password or keystone token
   * @param body a description of the request body to add to the request
   */
  // FIXME refactor username, password, and keystoneToken so they are embedded in headers rather
  // than separate fields
  public MultipartRequestSupplier(final Function<Map<String, String>, String> id,
      final Scheme scheme, final Function<Map<String, String>, String> host,
      final Integer port, final String uriRoot,
      final Function<Map<String, String>, String> container,
      final Function<Map<String, String>, String> object,
      final Function<Map<String, String>, Long> partSize,
      final int targetSessions,
      final Map<String, Function<Map<String, String>, String>> queryParameters,
      final boolean trailingSlash, final Map<String, Function<Map<String, String>, String>> headers,
      final List<Function<Map<String, String>, String>> context,
      final Function<Map<String, String>, Credential> credentials,
      final Function<Map<String, String>, Body> body, final boolean virtualHost) {

    this.id = id;
    this.scheme = checkNotNull(scheme);
    this.host = checkNotNull(host);
    this.port = port;
    this.uriRoot = uriRoot;
    this.container = container;
    this.object = object;
    this.partSize = partSize;
    this.targetSessions = targetSessions;
    this.queryParameters = ImmutableMap.copyOf(queryParameters);
    this.trailingSlash = trailingSlash;
    this.headers = ImmutableMap.copyOf(headers);
    this.context = ImmutableList.copyOf(context);
    this.credentials = credentials;
    this.body = body;
    this.virtualHost = virtualHost;
    this.randomNumber = new Random();
    this.actionableMultipartSessions = new ArrayList<MultipartInfo>();
    this.blockedMultipartSessions = new ArrayList<MultipartInfo>();
    this.multipartRequestMap = new ConcurrentHashMap<String, MultipartInfo>();
    this.inProgressSessions = new AtomicInteger();
    this.lockActionableMultipartSessions = new Object();
    this.lockBlockedMultipartSessions = new Object();
    this.lockBlockingWaitNotify = new Object();
  }

  private enum MultipartRequest {
    INITIATE, PART, PART_COPY, COMPLETE, ABORT, LIST_PARTS,
    INTERNAL_PENDING, INTERNAL_DONE, INTERNAL_ERROR
  }

  private class PartInfo {
    String partNumber;
    String partId;

    public PartInfo(String partNumber, String partId) {
      this.partNumber = partNumber;
      this.partId = partId;
    }
  }

  private class MultipartInfo {
    private Lock lockNextPartNumber;
    private Lock lockInProgressPartRequests;
    private Lock lockFinishedPartRequests;
    private Lock lockInProgressCompleteRequest;
    private Lock lockFinishedCompleteRequest;

    String containerName;
    String containerSuffix;
    String objectName;
    String bodyDataType;
    long objectSize;
    long partSize;
    long lastPartSize;
    String uploadId;
    Queue<PartInfo> partsInfo;
    int partRequestsToSend; //Part Requests
    int nextPartNumber;
    int inProgressPartRequests;
    int finishedPartRequests;
    boolean inProgressCompleteRequest;
    boolean finishedCompleteRequest;

    public MultipartInfo(String containerName, String objectName, String uploadId,
        long objectSize, long partSize, String containerSuffix, String bodyDataType) {
      this.lockNextPartNumber = new ReentrantLock();
      this.lockInProgressPartRequests = new ReentrantLock();
      this.lockFinishedPartRequests = new ReentrantLock();
      this.lockInProgressCompleteRequest = new ReentrantLock();
      this.lockFinishedCompleteRequest = new ReentrantLock();

      this.containerName = containerName;
      this.containerSuffix = containerSuffix;
      this.bodyDataType = bodyDataType;
      this.objectName = objectName;
      this.objectSize = objectSize;
      this.partSize = partSize; // bytes
      this.uploadId = uploadId;
      this.nextPartNumber = 0;
      this.inProgressPartRequests = 0;
      this.finishedPartRequests = 0;
      this.inProgressCompleteRequest = false;
      this.finishedCompleteRequest = false;
      this.partsInfo = new PriorityBlockingQueue<PartInfo>(200, new Comparator<PartInfo>() {
        @Override public int compare(PartInfo o1, PartInfo o2) {
          if(Integer.parseInt(o1.partNumber) < Integer.parseInt(o2.partNumber)) {
            return -1;
          } else if (Integer.parseInt(o1.partNumber) > Integer.parseInt(o2.partNumber)) {
            return 1;
          } else {
            return 0;
          }
        }
      });

      int parts = (int)(this.objectSize/this.partSize);

      // not all parts are the same size
      if(0 != (this.objectSize % this.partSize)) {
        this.partRequestsToSend = parts + 1;
        this.lastPartSize = this.objectSize % this.partSize;
        // parts are all the same size
      } else {
        this.partRequestsToSend = parts;
        this.lastPartSize = partSize;
      }
    }

    public MultipartRequest getNextMultipartRequest() {
      // all parts sent, no complete yet, send the complete
      MultipartRequest retVal;
      this.lockInProgressPartRequests.lock();
      this.lockFinishedPartRequests.lock();
      this.lockInProgressCompleteRequest.lock();
      this.lockFinishedCompleteRequest.lock();

      if((this.inProgressPartRequests == 0) &&
          (this.finishedCompleteRequest == false) &&
          (this.inProgressCompleteRequest == false) &&
          (this.finishedPartRequests == this.partRequestsToSend)) {
        retVal = MultipartRequest.COMPLETE;
        // all parts sent, complete sent, done
      } else if((this.finishedPartRequests == this.partRequestsToSend) &&
          (this.finishedCompleteRequest == true) && (this.inProgressCompleteRequest == false)) {
        retVal = MultipartRequest.INTERNAL_DONE;
        // haven't sent all the parts
      } else if((this.inProgressPartRequests + this.finishedPartRequests) < this.partRequestsToSend) {
        retVal = MultipartRequest.PART;
        // all parts sent, but not finished
      } else if((this.inProgressPartRequests + this.finishedPartRequests) == this.partRequestsToSend) {
        retVal = MultipartRequest.INTERNAL_PENDING;
      } else {
        retVal = MultipartRequest.INTERNAL_ERROR;
      }

      this.lockFinishedCompleteRequest.unlock();
      this.lockInProgressCompleteRequest.unlock();
      this.lockFinishedPartRequests.unlock();
      this.lockInProgressPartRequests.unlock();
      return retVal;
    }

    public long getNextPartSize() {
      long retVal;
      this.lockNextPartNumber.lock();

      if (this.nextPartNumber < this.partRequestsToSend) {
        retVal = this.partSize;
      } else {
        retVal = this.lastPartSize;
      }

      this.lockNextPartNumber.unlock();
      return retVal;
    }

    /*
    returns the next partNumber
     */
    public int startPartRequest() {
      int retVal;

      this.lockInProgressPartRequests.lock();
      this.lockNextPartNumber.lock();

      this.inProgressPartRequests++;
      this.nextPartNumber++;
      retVal = this.nextPartNumber;

      this.lockNextPartNumber.unlock();
      this.lockInProgressPartRequests.unlock();

      return retVal;
    }

    public void finishPartRequest(PartInfo partInfo) {
      this.partsInfo.add(partInfo);

      this.lockInProgressPartRequests.lock();
      this.lockFinishedPartRequests.lock();

      this.inProgressPartRequests--;
      this.finishedPartRequests++;

      this.lockFinishedPartRequests.unlock();
      this.lockInProgressPartRequests.unlock();
    }

    public String startCompleteRequest() {
      this.lockInProgressCompleteRequest.lock();

      this.inProgressCompleteRequest = true;

      this.lockInProgressCompleteRequest.unlock();
      return generateCompleteRequestBody();
    }

    public void finishCompleteRequest() {
      this.lockInProgressCompleteRequest.lock();
      this.lockFinishedCompleteRequest.lock();

      this.finishedCompleteRequest = true;
      this.inProgressCompleteRequest = false;

      this.lockFinishedCompleteRequest.unlock();
      this.lockInProgressCompleteRequest.unlock();
    }

    private String generateCompleteRequestBody() {
      String completeMultipartUploadBeginElement = "<CompleteMultipartUpload>";
      String completeMultipartUploadEndElement = "</CompleteMultipartUpload>";
      String partBeginElement = "<Part>";
      String partEndElement = "</Part>";
      String partNumberBeginElement = "<PartNumber>";
      String partNumberEndElement = "</PartNumber>";
      String etagBeginElement = "<ETag>";
      String etagEndElement = "</ETag>";

      PartInfo part;
      StringBuilder sb = new StringBuilder();
      sb.append(completeMultipartUploadBeginElement);

      while(!partsInfo.isEmpty()) {
        part = partsInfo.poll();
        sb.append(partBeginElement).append(partNumberBeginElement).append(part.partNumber).append(partNumberEndElement).append(etagBeginElement)
            .append(part.partId).append(etagEndElement).append(partEndElement);
      }

      sb.append(completeMultipartUploadEndElement);

      return sb.toString();
    }
  }

  @Subscribe
  public void update(final Pair<Request, Response> result) {
    Request request = result.getKey();
    Response response = result.getValue();
    Map<String, String> requestContext  = request.getContext();
    Map<String, String> responseContext = response.getContext();
    Map<String, String> responseHeaders = response.headers();

    String multipartrequestOperation = requestContext.get(Context.X_OG_MULTIPART_REQUEST);
    if(multipartrequestOperation == null) {
      // not a multipart operation so just return
      return;
    }
    String requestBodyDataType = requestContext.get(Context.X_OG_MULTIPART_BODY_DATA_TYPE);
    String requestContainerName = requestContext.get(Context.X_OG_MULTIPART_CONTAINER);
    String requestContainerSuffix = requestContext.get(Context.X_OG_CONTAINER_SUFFIX);
    String requestObjectName = requestContext.get(Context.X_OG_OBJECT_NAME);
    String requestObjectSize = requestContext.get(Context.X_OG_OBJECT_SIZE);
    String requestPartSize = requestContext.get(Context.X_OG_MULTIPART_PART_SIZE);
    String requestUploadId = requestContext.get(Context.X_OG_MULTIPART_UPLOAD_ID);
    String requestPartNumber = requestContext.get(Context.X_OG_MULTIPART_PART_NUMBER);
    String responseUploadId = responseContext.get(Context.X_OG_MULTIPART_UPLOAD_ID);
    String responsePartId = responseHeaders.get("ETag");

    MultipartInfo multipartInfo;
    if (multipartrequestOperation == MultipartRequest.INITIATE.toString()) {
      if(response.getStatusCode() != 200) {
        // bad response, so just return
        _logger.info("Multipart Initiate Failed with " + response.getStatusCode());
        this.inProgressSessions.decrementAndGet();
        return;
      }
      multipartInfo = new MultipartInfo(requestContainerName, requestObjectName, responseUploadId,
          Long.parseLong(requestObjectSize), Long.parseLong(requestPartSize), requestContainerSuffix, requestBodyDataType);
      this.multipartRequestMap.put(responseUploadId, multipartInfo);
      synchronized (this.lockActionableMultipartSessions) {
        this.actionableMultipartSessions.add(multipartInfo);
        synchronized (this.lockBlockingWaitNotify) {
          this.lockBlockingWaitNotify.notifyAll();
        }
      }
    } else if (multipartrequestOperation == MultipartRequest.PART.toString()) {
      multipartInfo = multipartRequestMap.get(requestUploadId);
      synchronized (this.lockActionableMultipartSessions) {
        synchronized (this.lockBlockedMultipartSessions) {
          multipartInfo.finishPartRequest(new PartInfo(requestPartNumber, responsePartId));
          // multipart info only gets put on blocked when INTERNAL_PENDING is
          // observed on the get() call. Put it back in active when all parts are in
          if (multipartInfo.getNextMultipartRequest() == MultipartRequest.COMPLETE) {
            this.blockedMultipartSessions.remove(multipartInfo);
            this.actionableMultipartSessions.add(multipartInfo);
            synchronized (this.lockBlockingWaitNotify) {
              this.lockBlockingWaitNotify.notifyAll();
            }
          }
        }
      }
    } else if (multipartrequestOperation == MultipartRequest.COMPLETE.toString()) {
      this.inProgressSessions.getAndDecrement();
      multipartInfo = multipartRequestMap.get(requestUploadId);
      multipartInfo.finishCompleteRequest();
      this.multipartRequestMap.remove(multipartInfo);
      synchronized (this.lockBlockingWaitNotify) {
        this.lockBlockingWaitNotify.notify();
      }
    } else if (multipartrequestOperation == MultipartRequest.ABORT.toString()) {
      //TODO
    }
  }

  @Override
  public Request get() {
    final Map<String, String> requestContext = Maps.newHashMap();

    HttpRequest.Builder builder;

    while(true) {
      if(this.inProgressSessions.get() < this.targetSessions) {
        this.inProgressSessions.getAndIncrement();
        // populate the context map with any relevant metadata for this request
        // based on what the current operation is
        for (final Function<Map<String, String>, String> function : this.context) {
          // return value for context functions is ignored
          function.apply(requestContext);
        }

        // create the initiate request
        builder = createInitiateRequest(requestContext);
        builder.withQueryParameter(UPLOADS, "");
        break;
      } else if (this.actionableMultipartSessions.size() > 0){
        MultipartInfo activeMultipartInfo = getActiveMultipartOperation();
        MultipartRequest multipartRequest = activeMultipartInfo.getNextMultipartRequest();
        switch(multipartRequest) {
          case PART:
            int partNumber = activeMultipartInfo.startPartRequest();
            builder = createPartRequest(requestContext, partNumber,
                activeMultipartInfo.uploadId, activeMultipartInfo.objectName,
                activeMultipartInfo.getNextPartSize(), activeMultipartInfo.containerName,
                activeMultipartInfo.bodyDataType);
            builder.withQueryParameter(PART_NUMBER, String.valueOf(partNumber));
            builder.withQueryParameter(UPLOAD_ID, activeMultipartInfo.uploadId);
            break;
          case COMPLETE:
            builder = createCompleteRequest(requestContext, activeMultipartInfo.uploadId,
                activeMultipartInfo.objectName, activeMultipartInfo.startCompleteRequest(),
                activeMultipartInfo.containerName, activeMultipartInfo.containerSuffix);
            builder.withQueryParameter(UPLOAD_ID, activeMultipartInfo.uploadId);
            break;
          case ABORT:
            builder = createAbortRequest(requestContext, activeMultipartInfo.uploadId,
                activeMultipartInfo.objectName, activeMultipartInfo.containerName);
            builder.withQueryParameter(UPLOAD_ID, activeMultipartInfo.uploadId);
            break;
          default:
            return null;
        }

        if (multipartRequest == MultipartRequest.COMPLETE) {
          synchronized (this.lockActionableMultipartSessions) {
            this.actionableMultipartSessions.remove(activeMultipartInfo);
          }
        }
        synchronized (this.lockActionableMultipartSessions) {
          synchronized (this.lockBlockedMultipartSessions) {
            if(activeMultipartInfo.getNextMultipartRequest() == MultipartRequest.INTERNAL_PENDING) {
              this.actionableMultipartSessions.remove(activeMultipartInfo);
              this.blockedMultipartSessions.add(activeMultipartInfo);
            }
          }
        }
        break;
      } else {
        synchronized (this.lockBlockingWaitNotify) {
          try {
            this.lockBlockingWaitNotify.wait();
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
          }
        }
      }
    }

    if (this.headers != null) {
      for (final Map.Entry<String, Function<Map<String, String>, String>> header : this.headers
          .entrySet()) {
        builder.withHeader(header.getKey(), header.getValue().apply(requestContext));
      }
    }

    if (this.id != null) {
      builder.withContext(Context.X_OG_REQUEST_ID, this.id.apply(requestContext));
    }

    if (credentials != null) {
      Credential credential = this.credentials.apply(requestContext);
      String username = credential.getUsername();
      String password = credential.getPassword();
      String keystoneToken = credential.getKeystoneToken();

      if(username != null)
        builder.withContext(Context.X_OG_USERNAME, username);
      if(password != null)
        builder.withContext(Context.X_OG_PASSWORD, password);
      if(keystoneToken != null)
        builder.withContext(Context.X_OG_KEYSTONE_TOKEN, keystoneToken);
    }

    for (final Map.Entry<String, String> entry : requestContext.entrySet()) {
      builder.withContext(entry.getKey(), entry.getValue());
    }

    //TODO clean up the magic value
    builder.withContext(Context.X_OG_RESPONSE_BODY_CONSUMER, "s3.multipart");

    return builder.build();
  }

  private MultipartInfo getActiveMultipartOperation() {
    synchronized (this.lockActionableMultipartSessions) {
      int numActionableSessions = this.actionableMultipartSessions.size();
      if (numActionableSessions > 0) {
        int sessionIndex = this.randomNumber.nextInt(numActionableSessions);
        return this.actionableMultipartSessions.get(sessionIndex);
      } else {
        return null;
      }
    }
  }

  private HttpRequest.Builder createInitiateRequest(final Map<String, String> context) {
    Body fullBody = this.body.apply(context);
    Long partSize = this.partSize.apply(context); // bytes
    String containerName = this.container.apply(context);

    final HttpRequest.Builder builder =
        new HttpRequest.Builder(Method.POST,
            getUrl(context, MultipartRequest.INITIATE, NO_PART, null, null, containerName),
            Operation.MULTIPART_WRITE_INITIATE);

    builder.withContext(Context.X_OG_OBJECT_SIZE, String.valueOf(fullBody.getSize()));
    builder.withContext(Context.X_OG_MULTIPART_BODY_DATA_TYPE, fullBody.getDataType().toString());
    builder.withContext(Context.X_OG_MULTIPART_REQUEST, MultipartRequest.INITIATE.toString());
    builder.withContext(Context.X_OG_MULTIPART_CONTAINER, containerName);
    builder.withContext(Context.X_OG_MULTIPART_PART_SIZE, partSize.toString());

    return builder;
  }

  private HttpRequest.Builder createPartRequest(final Map<String, String> context,
      int partNumber, String uploadId, String objectName, long partSize, String containerName, String bodyDataType) {
    final HttpRequest.Builder builder =
        new HttpRequest.Builder(Method.PUT, getUrl(context, MultipartRequest.PART,
            partNumber, uploadId, objectName, containerName), Operation.MULTIPART_WRITE_PART);

    if(bodyDataType == DataType.RANDOM.toString()) {
      builder.withBody(Bodies.random(partSize));
    } else if(bodyDataType == DataType.ZEROES.toString()) {
      builder.withBody(Bodies.zeroes(partSize));
    } else {
      builder.withBody(Bodies.random(partSize));
    }

    builder.withContext(Context.X_OG_MULTIPART_REQUEST, MultipartRequest.PART.toString());
    builder.withContext(Context.X_OG_MULTIPART_PART_NUMBER, String.valueOf(partNumber));
    builder.withContext(Context.X_OG_MULTIPART_UPLOAD_ID, uploadId);
    builder.withContext(Context.X_OG_OBJECT_NAME, objectName);
    builder.withContext(Context.X_OG_OBJECT_SIZE, String.valueOf(partSize));

    return builder;
  }

  private HttpRequest.Builder createCompleteRequest(final Map<String, String> context,
      String uploadId, String objectName, String body, String containerName, String containerSuffix) {
    final HttpRequest.Builder builder =
        new HttpRequest.Builder(Method.POST,
            getUrl(context, MultipartRequest.COMPLETE, NO_PART, uploadId, objectName,
                containerName), Operation.MULTIPART_WRITE_COMPLETE);

    builder.withBody(Bodies.custom(body.length(), body));

    builder.withContext(Context.X_OG_MULTIPART_REQUEST, MultipartRequest.COMPLETE.toString());
    builder.withContext(Context.X_OG_MULTIPART_UPLOAD_ID, uploadId);
    builder.withContext(Context.X_OG_OBJECT_NAME, objectName);
    builder.withContext(Context.X_OG_OBJECT_SIZE, String.valueOf(body.length()));
    builder.withContext(Context.X_OG_CONTAINER_SUFFIX, containerSuffix);

    return builder;
  }

  private HttpRequest.Builder createAbortRequest(final Map<String, String> context, String uploadId,
      String objectName, String containerName) {
    final HttpRequest.Builder builder =
        new HttpRequest.Builder(Method.DELETE,
            getUrl(context, MultipartRequest.ABORT, NO_PART, uploadId, objectName, containerName),
            Operation.MULTIPART_WRITE_ABORT);

    builder.withContext(Context.X_OG_OBJECT_NAME, objectName);

    return builder;
  }

  private URI getUrl(final Map<String, String> context, MultipartRequest multipartRequest,
      int partNumber, String uploadId, String objectName, String containerName) {

    final StringBuilder s = new StringBuilder().append(this.scheme).append("://");
    appendHost(s, context, multipartRequest, containerName);
    appendPort(s);
    appendPath(s, context, multipartRequest, objectName, containerName);
    appendTrailingSlash(s);
    appendQueryParams(s, multipartRequest, partNumber, uploadId);

    try {
      return new URI(s.toString());
    } catch (final URISyntaxException e) {
      // Wrapping checked exception as unchecked because most callers will not be able to handle
      // it and I don't want to include URISyntaxException in the entire signature chain
      throw new IllegalArgumentException(e);
    }
  }

  private void appendHost(final StringBuilder s, final Map<String, String> context,
      MultipartRequest multipartRequest, String containerName) {
    if (this.virtualHost) {
      if (containerName != null)  {
        s.append(containerName).append(".");
      }
    }

    s.append(this.host.apply(context));
  }

  private void appendPort(final StringBuilder s) {
    if (this.port != null) {
      s.append(":").append(this.port);
    }
  }

  private void appendPath(final StringBuilder s, final Map<String, String> context,
      MultipartRequest multipartRequest, String objectName, String containerName) {
    if (!this.virtualHost) {
      s.append("/");
      if (this.uriRoot != null) {
        s.append(this.uriRoot).append("/");
      }

      if (containerName != null) {
        s.append(containerName);
      }
    }

    if (this.object != null && multipartRequest == MultipartRequest.INITIATE) {
      s.append("/").append(this.object.apply(context));
    } else if(objectName != null) {
      s.append("/").append(objectName);
    }
  }

  private void appendTrailingSlash(final StringBuilder s) {
    if (this.trailingSlash) {
      s.append("/");
    }
  }

  private void appendQueryParams(final StringBuilder s, MultipartRequest multipartRequest,
      int partNumber, String uploadId) {
    final Map<String, String> queryParamsMap = Maps.newHashMap();
    String queryParams = null;

    switch(multipartRequest) {
      case INITIATE:
        queryParams = UPLOADS;
        break;
      case PART:
        queryParamsMap.put(PART_NUMBER, String.valueOf(partNumber));
        queryParamsMap.put(UPLOAD_ID, uploadId);
        break;
      case COMPLETE:
        queryParamsMap.put(UPLOAD_ID, uploadId);
        break;
      case ABORT:
        queryParamsMap.put(UPLOAD_ID, uploadId);
        break;
      default:
        return;
    }

    if (!queryParamsMap.isEmpty()) {
      queryParams = PARAM_JOINER.join(queryParamsMap);
    }
    if (queryParams.length() > 0) {
      s.append("?").append(queryParams);
    }
  }

  @Override
  public String toString() {
    return String.format(
        "RequestSupplier [" + "scheme=%s,%n" + "host=%s,%n" + "port=%s,%n"
            + "uriRoot=%s,%n" + "container=%s,%n" + "object=%s,%n" + "queryParameters=%s,%n"
            + "trailingSlash=%s,%n" + "headers=%s,%n" + "body=%s%n" + "]",
        this.scheme, this.host, this.port, this.uriRoot, this.container, this.object,
        this.queryParameters, this.trailingSlash, this.headers, this.body);
  }
}
