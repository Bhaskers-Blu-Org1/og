/*
 * Copyright (C) 2005-2015 Cleversafe, Inc. All rights reserved.
 * 
 * Contact Information: Cleversafe, Inc. 222 South Riverside Plaza Suite 1700 Chicago, IL 60606, USA
 * 
 * licensing@cleversafe.com
 */

package com.cleversafe.og.supplier;

import com.cleversafe.og.api.Body;
import com.cleversafe.og.api.Method;
import com.cleversafe.og.api.Operation;
import com.cleversafe.og.api.Request;
import com.cleversafe.og.api.Response;
import com.cleversafe.og.http.Bodies;
import com.cleversafe.og.http.Credential;
import com.cleversafe.og.http.HttpRequest;
import com.cleversafe.og.http.Scheme;
import com.cleversafe.og.util.Context;
import com.cleversafe.og.util.Pair;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Supplier;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.google.common.eventbus.Subscribe;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedDeque;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * A supplier of multipart requests
 * 
 * @since 1.0
 */
public class MultipartRequestSupplier implements Supplier<Request> {
  private static final Joiner.MapJoiner PARAM_JOINER = Joiner.on('&').withKeyValueSeparator("=");
  private final Function<Map<String, String>, String> id;
  private final Method method;
  private final Scheme scheme;
  private final Function<Map<String, String>, String> host;
  private final Integer port;
  private final String uriRoot;
  private final Function<Map<String, String>, String> container;
  private final Function<Map<String, String>, String> object;
  private final Map<String, Function<Map<String, String>, String>> queryParameters;
  private final boolean trailingSlash;
  private final Map<String, Function<Map<String, String>, String>> headers;
  private final List<Function<Map<String, String>, String>> context;
  private final Function<Map<String, String>, Credential> credentials;
  private final Function<Map<String, String>, Body> body;
  private final boolean virtualHost;
  private final Operation operation;

  // constants
  private final int NO_PART = -1;
  private final String UPLOAD_ID = "uploadId";
  private final String PART_NUMBER = "partNumber";
  private final String UPLOADS = "uploads";
  private final int PART_SIZE_BYTES = 5243000; //5MiB

  // request queues and hashmap
  private final Deque<MultipartInfo> inProgressMultipartRequests;
  private final Deque<MultipartInfo> toBeCompletedMultipartRequests;
  private final Map<String, MultipartInfo> inProgressCompleteMultipartRequests;
  private final Map<String, MultipartInfo> multipartRequestMap;

  /**
   * Creates an instance
   *
   * @param id a supplier of ids to uniquely identify each request that is generated by this
   *        instance
   * @param scheme
   * @param host
   * @param port
   * @param uriRoot the base url part e.g. /soh/, /, /s3/
   * @param container
   * @param object
   * @param queryParameters static query parameters to all requests
   * @param trailingSlash whether or not to add a trailing slash to the url
   * @param headers headers to add to each request; header values may be dynamic
   * @param context request metadata to be sent with the created request
   * @param credentials username/password or keystone token
   * @param body a description of the request body to add to the request
   */
  // FIXME refactor username, password, and keystoneToken so they are embedded in headers rather
  // than separate fields
  public MultipartRequestSupplier(final Operation operation, final Function<Map<String, String>, String> id,
      final Scheme scheme, final Function<Map<String, String>, String> host,
      final Integer port, final String uriRoot,
      final Function<Map<String, String>, String> container,
      final Function<Map<String, String>, String> object,
      final Map<String, Function<Map<String, String>, String>> queryParameters,
      final boolean trailingSlash, final Map<String, Function<Map<String, String>, String>> headers,
      final List<Function<Map<String, String>, String>> context,
      final Function<Map<String, String>, Credential> credentials,
      final Function<Map<String, String>, Body> body, final boolean virtualHost) {

    this.id = id;
    this.method = null;
    this.scheme = checkNotNull(scheme);
    this.host = checkNotNull(host);
    this.port = port;
    this.uriRoot = uriRoot;
    this.container = container;
    this.object = object;
    this.queryParameters = ImmutableMap.copyOf(queryParameters);
    this.trailingSlash = trailingSlash;
    this.headers = ImmutableMap.copyOf(headers);
    this.context = ImmutableList.copyOf(context);
    this.credentials = credentials;
    this.body = body;
    this.virtualHost = virtualHost;
    this.operation = operation;
    this.inProgressMultipartRequests = new ConcurrentLinkedDeque<MultipartInfo>();
    this.toBeCompletedMultipartRequests = new ConcurrentLinkedDeque<MultipartInfo>();
    this.inProgressCompleteMultipartRequests = new ConcurrentHashMap<String, MultipartInfo>();
    this.multipartRequestMap = new ConcurrentHashMap<String, MultipartInfo>();
  }

  private enum MultipartRequest {
    INITIATE, PART, PART_COPY, COMPLETE, ABORT, LIST_PARTS,
    INTERNAL_PENDING, INTERNAL_DONE, INTERNAL_ERROR
  }

  private class PartInfo {
    String partNumber;
    String partId;

    public PartInfo(String partNumber, String partId) {
      this.partNumber = partNumber;
      this.partId = partId;
    }
  }

  private class MultipartInfo {
    String objectName;
    int objectSize;
    int partSize;
    int lastPartSize;
    String uploadId;
    ArrayList<PartInfo> partsInfo;
    int partRequestsToSend; //Part Requests
    int nextPartNumber;
    int inProgressPartRequests;
    int finishedPartRequests;
    boolean finishedCompleteRequest;
    boolean inProgressCompleteRequest;

    public MultipartInfo(String objectName, String uploadId, int objectSize, int partSize) {
      this.objectName = objectName;
      this.objectSize = objectSize;
      this.partSize = partSize;
      this.uploadId = uploadId;
      this.nextPartNumber = 0;
      this.inProgressPartRequests = 0;
      this.finishedPartRequests = 0;
      this.inProgressCompleteRequest = false;
      this.finishedCompleteRequest = false;
      this.partsInfo = new ArrayList<PartInfo>();

      double parts = (double)objectSize/(double)partSize;
      double flooredParts = Math.floor(parts);

      // not all parts are the same size
      if(parts != flooredParts) {
        this.partRequestsToSend = (int) parts + 1;
        this.lastPartSize = this.objectSize - (this.partSize * (this.partRequestsToSend - 1));
        // parts are all the same size
      } else {
        this.partRequestsToSend = (int) parts;
        this.lastPartSize = partSize;
      }

    }

    public MultipartRequest getNextMultipartRequest() {
      // all parts sent, no complete yet, send the complete
      if((this.inProgressPartRequests == 0) &&
        (this.finishedCompleteRequest == false) &&
        (this.inProgressCompleteRequest == false) &&
        (this.finishedPartRequests == this.partRequestsToSend)) {
        return MultipartRequest.COMPLETE;
        // all parts sent, complete sent, done
      } else if((this.finishedPartRequests == this.partRequestsToSend) &&
          (this.finishedCompleteRequest == true) && (this.inProgressCompleteRequest == false)) {
        return MultipartRequest.INTERNAL_DONE;
        // haven't sent all the parts
      } else if((this.inProgressPartRequests + this.finishedPartRequests) < this.partRequestsToSend) {
        return MultipartRequest.PART;
        // all parts sent, but not finished
      } else if((this.inProgressPartRequests + this.finishedPartRequests) == this.partRequestsToSend) {
        return MultipartRequest.INTERNAL_PENDING;
      } else {
        return MultipartRequest.INTERNAL_ERROR;
      }
    }

    public int getNextPartSize() {
      if (this.nextPartNumber < this.partRequestsToSend) {
        return this.partSize;
      } else {
        return this.lastPartSize;
      }
    }

    /*
    returns the next partNumber
     */
    public Integer startPartRequest() {
      this.inProgressPartRequests++;
      this.nextPartNumber++;
      return this.nextPartNumber;
    }

    public void finishPartRequest(PartInfo partInfo) {
      this.partsInfo.add(partInfo);
      this.inProgressPartRequests--;
      this.finishedPartRequests++;
    }

    public String startCompleteRequest() {
      this.inProgressCompleteRequest = true;
      return generateCompleteRequestBody();
    }

    public void finishCompleteRequest() {
      this.finishedCompleteRequest = true;
      this.inProgressCompleteRequest = false;
    }

    private String generateCompleteRequestBody() {
      String completeMultipartUploadBeginElement = "<CompleteMultipartUpload>";
      String completeMultipartUploadEndElement = "</CompleteMultipartUpload>";
      String partBeginElement = "<Part>";
      String partEndElement = "</Part>";
      String partNumberBeginElement = "<PartNumber>";
      String partNumberEndElement = "</PartNumber>";
      String etagBeginElement = "<ETag>";
      String etagEndElement = "</ETag>";
      
      String completeRequestBody = completeMultipartUploadBeginElement;

      for (PartInfo part : this.partsInfo) {
        completeRequestBody += partBeginElement + partNumberBeginElement + part.partNumber +
            partNumberEndElement + etagBeginElement + part.partId + etagEndElement + partEndElement;
      }

      completeRequestBody += completeMultipartUploadEndElement;

      return completeRequestBody;
    }
  }

  @Subscribe
  public void update(final Pair<Request, Response> result) {
    Request request = result.getKey();
    Response response = result.getValue();
    Map<String, String> requestContext  = request.getContext();
    Map<String, String> responseContext = response.getContext();
    Map<String, String> responseHeaders = response.headers();

    String multipartrequestOperation = requestContext.get(Context.X_OG_MULTIPART_REQUEST);
    String requestObjectName = requestContext.get(Context.X_OG_OBJECT_NAME);
    String requestObjectSize = requestContext.get(Context.X_OG_OBJECT_SIZE);
    String requestUploadId = requestContext.get(Context.X_OG_MULTIPART_UPLOAD_ID);
    String requestPartNumber = requestContext.get(Context.X_OG_MULTIPART_PART_NUMBER);
    String responseUploadId = responseContext.get(Context.X_OG_MULTIPART_UPLOAD_ID);
    String responsePartId = responseHeaders.get("ETag");

    MultipartInfo multipartInfo;

    if (multipartrequestOperation == MultipartRequest.INITIATE.toString()) {
      multipartInfo = new MultipartInfo(requestObjectName, responseUploadId,
          Integer.valueOf(requestObjectSize), PART_SIZE_BYTES);
      multipartRequestMap.put(responseUploadId, multipartInfo);
      inProgressMultipartRequests.add(multipartInfo);
    } else if (multipartrequestOperation == MultipartRequest.PART.toString()) {
      multipartInfo = multipartRequestMap.get(requestUploadId);
      multipartInfo.finishPartRequest(new PartInfo(requestPartNumber, responsePartId));
    } else if (multipartrequestOperation == MultipartRequest.COMPLETE.toString()) {
      multipartInfo = multipartRequestMap.get(requestUploadId);
      multipartInfo.finishCompleteRequest();
    } else if (multipartrequestOperation == MultipartRequest.ABORT.toString()) {
      //TODO
    }
  }

  @Override
  public Request get() {
    final Map<String, String> requestContext = Maps.newHashMap();

    HttpRequest.Builder builder;

    MultipartInfo activeMultipartInfo = getActiveMultipartOperation();

    // populate the context map with any relevant metadata for this request
    // based on what the current operation is
    if (activeMultipartInfo == null){
      for (final Function<Map<String, String>, String> function : this.context) {
        // return value for context functions is ignored
        function.apply(requestContext);
      }
    }

    if(activeMultipartInfo == null) {
      builder = createInitiateRequest(requestContext);
    } else {
      switch(activeMultipartInfo.getNextMultipartRequest()) {
        case PART:
          builder = createPartRequest(requestContext, activeMultipartInfo.startPartRequest(),
              activeMultipartInfo.uploadId, activeMultipartInfo.objectName, activeMultipartInfo.getNextPartSize());
          break;
        case COMPLETE:
          activeMultipartInfo.startCompleteRequest();
          builder = createCompleteRequest(requestContext, activeMultipartInfo.uploadId,
              activeMultipartInfo.objectName, activeMultipartInfo.generateCompleteRequestBody());
          break;
        case ABORT:
          builder = createAbortRequest(requestContext, activeMultipartInfo.uploadId,
              activeMultipartInfo.objectName);
          break;
        default:
          return null;
      }
    }

    if (this.id != null) {
      builder.withContext(Context.X_OG_REQUEST_ID, this.id.apply(requestContext));
    }

    if (credentials != null) {
      Credential credential = this.credentials.apply(requestContext);
      String username = credential.getUsername();
      String password = credential.getPassword();
      String keystoneToken = credential.getKeystoneToken();

      if(username != null)
        builder.withContext(Context.X_OG_USERNAME, username);
      if(password != null)
        builder.withContext(Context.X_OG_PASSWORD, password);
      if(keystoneToken != null)
        builder.withContext(Context.X_OG_KEYSTONE_TOKEN, keystoneToken);
    }

    for (final Map.Entry<String, String> entry : requestContext.entrySet()) {
      builder.withContext(entry.getKey(), entry.getValue());
    }

    //TODO clean up the magic value
    builder.withContext(Context.X_OG_RESPONSE_BODY_CONSUMER, "s3.multipart");

    return builder.build();
  }

  private MultipartInfo getActiveMultipartOperation() {
    Deque<MultipartInfo> noActionMultipart = new ConcurrentLinkedDeque<MultipartInfo>();
    MultipartInfo multipartToCheck;
    MultipartInfo multipartToReturn = null;

    // check the "To Be Completed" list first
    // MultipartRequest.PART isn't possible here
    while(!this.toBeCompletedMultipartRequests.isEmpty()) {
      multipartToCheck = toBeCompletedMultipartRequests.pollFirst();
      MultipartRequest nextRequest = multipartToCheck.getNextMultipartRequest();
      // remove from queue if done
      if(nextRequest == MultipartRequest.INTERNAL_DONE) {
        continue;
        // any other state, take no action
      } else if(nextRequest != MultipartRequest.COMPLETE) {
        noActionMultipart.addFirst(multipartToCheck);
        continue;
        // if complete, we have our action
      } else {
        multipartToReturn = multipartToCheck;
        break;
      }
    }

    while(!noActionMultipart.isEmpty()) {
      this.toBeCompletedMultipartRequests.addFirst(noActionMultipart.pollFirst());
    }

    if(multipartToReturn != null) {
      return multipartToReturn;
    }

    // check the "In Progress" list
    while(!this.inProgressMultipartRequests.isEmpty()) {
      multipartToCheck = inProgressMultipartRequests.pollFirst();
      MultipartRequest nextRequest = multipartToCheck.getNextMultipartRequest();
      // if complete, we have our action
      // move it to the toBeCompletedQueue
      if(nextRequest == MultipartRequest.COMPLETE) {
        multipartToReturn = multipartToCheck;
        this.toBeCompletedMultipartRequests.addLast(multipartToCheck);
        break;
        // if part, we have our action
      } else if(nextRequest == MultipartRequest.PART) {
        multipartToReturn = multipartToCheck;
        this.inProgressMultipartRequests.addFirst(multipartToCheck);
        break;
        // if waiting for parts to complete, put on toBeCompletedQueue
      } else if(nextRequest == MultipartRequest.INTERNAL_PENDING) {
        this.toBeCompletedMultipartRequests.addLast(multipartToCheck);
        continue;
      }
    }

    return multipartToReturn;

  }

  private HttpRequest.Builder createInitiateRequest(final Map<String, String> context) {
    final HttpRequest.Builder builder =
        new HttpRequest.Builder(Method.POST,
            getUrl(context, MultipartRequest.INITIATE, NO_PART, null, null),
            Operation.MULTIPART_WRITE_INITIATE);

    //TODO add list of allowable headers
    for (final Map.Entry<String, Function<Map<String, String>, String>> header : this.headers
        .entrySet()) {
      builder.withHeader(header.getKey(), header.getValue().apply(context));
    }

    Body fullBody = this.body.apply(context);

    builder.withContext(Context.X_OG_OBJECT_SIZE, String.valueOf(fullBody.getSize()));
    builder.withContext(Context.X_OG_MULTIPART_REQUEST, MultipartRequest.INITIATE.toString());

    return builder;
  }

  private HttpRequest.Builder createPartRequest(final Map<String, String> context,
      int partNumber, String uploadId, String objectName, int partSize) {
    final HttpRequest.Builder builder =
        new HttpRequest.Builder(Method.PUT, getUrl(context, MultipartRequest.PART,
            partNumber, uploadId, objectName), Operation.MULTIPART_WRITE_PART);

    //TODO add list of allowable headers
    for (final Map.Entry<String, Function<Map<String, String>, String>> header : this.headers
        .entrySet()) {
      builder.withHeader(header.getKey(), header.getValue().apply(context));
    }

    builder.withBody(Bodies.random(partSize));

    builder.withContext(Context.X_OG_MULTIPART_REQUEST, MultipartRequest.PART.toString());
    builder.withContext(Context.X_OG_MULTIPART_PART_NUMBER, String.valueOf(partNumber));
    builder.withContext(Context.X_OG_MULTIPART_UPLOAD_ID, uploadId);
    builder.withContext(Context.X_OG_OBJECT_NAME, objectName);
    builder.withContext(Context.X_OG_OBJECT_SIZE, String.valueOf(partSize));

    return builder;
  }

  private HttpRequest.Builder createCompleteRequest(final Map<String, String> context,
      String uploadId, String objectName, String body) {
    final HttpRequest.Builder builder =
        new HttpRequest.Builder(Method.POST,
            getUrl(context, MultipartRequest.COMPLETE, NO_PART, uploadId, objectName),
            Operation.MULTIPART_WRITE_COMPLETE);

    //TODO add list of allowable headers
    for (final Map.Entry<String, Function<Map<String, String>, String>> header : this.headers
        .entrySet()) {
      builder.withHeader(header.getKey(), header.getValue().apply(context));
    }

    builder.withBody(Bodies.custom(body.length(), body));

    builder.withContext(Context.X_OG_MULTIPART_REQUEST, MultipartRequest.COMPLETE.toString());
    builder.withContext(Context.X_OG_MULTIPART_UPLOAD_ID, uploadId);
    builder.withContext(Context.X_OG_OBJECT_NAME, objectName);
    builder.withContext(Context.X_OG_OBJECT_SIZE, String.valueOf(body.length()));

    return builder;
  }

  private HttpRequest.Builder createAbortRequest(final Map<String, String> context, String uploadId, String objectName) {
    final HttpRequest.Builder builder =
        new HttpRequest.Builder(Method.DELETE,
            getUrl(context, MultipartRequest.ABORT, NO_PART, uploadId, objectName),
            Operation.MULTIPART_WRITE_ABORT);

    //TODO add list of allowable headers
    for (final Map.Entry<String, Function<Map<String, String>, String>> header : this.headers
        .entrySet()) {
      builder.withHeader(header.getKey(), header.getValue().apply(context));
    }

    builder.withContext(Context.X_OG_OBJECT_NAME, objectName);

    return builder;
  }

  private URI getUrl(final Map<String, String> context, MultipartRequest multipartRequest,
      int partNumber, String uploadId, String objectName) {

    final StringBuilder s = new StringBuilder().append(this.scheme).append("://");
    appendHost(s, context);
    appendPort(s);
    appendPath(s, context, multipartRequest, objectName);
    appendTrailingSlash(s);
    appendQueryParams(s, multipartRequest, partNumber, uploadId);

    try {
      return new URI(s.toString());
    } catch (final URISyntaxException e) {
      // Wrapping checked exception as unchecked because most callers will not be able to handle
      // it and I don't want to include URISyntaxException in the entire signature chain
      throw new IllegalArgumentException(e);
    }
  }

  private void appendHost(final StringBuilder s, final Map<String, String> context) {
    if (this.virtualHost) {
      if(this.container != null) {
        s.append(this.container.apply(context)).append(".");
      }
    }

    s.append(this.host.apply(context));
  }

  private void appendPort(final StringBuilder s) {
    if (this.port != null) {
      s.append(":").append(this.port);
    }
  }

  private void appendPath(final StringBuilder s, final Map<String, String> context,
      MultipartRequest multipartRequest, String objectName) {
    if (!this.virtualHost) {
      s.append("/");
      if (this.uriRoot != null) {
        s.append(this.uriRoot).append("/");
      }

      if (this.container != null) {
        s.append(this.container.apply(context));
      }
    }

    if (this.object != null && multipartRequest == MultipartRequest.INITIATE) {
      s.append("/").append(this.object.apply(context));
    } else {
      s.append("/").append(objectName);
    }
  }

  private void appendTrailingSlash(final StringBuilder s) {
    if (this.trailingSlash) {
      s.append("/");
    }
  }

  private void appendQueryParams(final StringBuilder s, MultipartRequest multipartRequest,
      int partNumber, String uploadId) {
    final Map<String, String> queryParamsMap = Maps.newHashMap();
    String queryParams = null;

    switch(multipartRequest) {
      case INITIATE:
        queryParams = UPLOADS;
        break;
      case PART:
        queryParamsMap.put(PART_NUMBER, String.valueOf(partNumber));
        queryParamsMap.put(UPLOAD_ID, uploadId);
        break;
      case COMPLETE:
        queryParamsMap.put(UPLOAD_ID, uploadId);
        break;
      case ABORT:
        queryParamsMap.put(UPLOAD_ID, uploadId);
        break;
      default:
        return;
    }

    if (!queryParamsMap.isEmpty()) {
      queryParams = PARAM_JOINER.join(queryParamsMap);
    }
    if (queryParams.length() > 0) {
      s.append("?").append(queryParams);
    }
  }

  @Override
  public String toString() {
    return String.format(
        "RequestSupplier [%n" + "method=%s,%n" + "scheme=%s,%n" + "host=%s,%n" + "port=%s,%n"
            + "uriRoot=%s,%n" + "container=%s,%n" + "object=%s,%n" + "queryParameters=%s,%n"
            + "trailingSlash=%s,%n" + "headers=%s,%n" + "body=%s%n" + "]",
        this.method, this.scheme, this.host, this.port, this.uriRoot, this.container, this.object,
        this.queryParameters, this.trailingSlash, this.headers, this.body);
  }
}
