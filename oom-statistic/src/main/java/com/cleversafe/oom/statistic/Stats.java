//
// Copyright (C) 2005-2011 Cleversafe, Inc. All rights reserved.
//
// Contact Information:
// Cleversafe, Inc.
// 222 South Riverside Plaza
// Suite 1700
// Chicago, IL 60606, USA
//
// licensing@cleversafe.com
//
// END-OF-HEADER
//
// -----------------------
// @author: rveitch
//
// Date: Oct 26, 2013
// ---------------------

package com.cleversafe.oom.statistic;

import java.util.HashMap;
import java.util.Map;

import org.apache.commons.lang3.Validate;

import com.cleversafe.oom.operation.OperationType;

/**
 * A statistics implementation for managing counters, calculating statistics, and taking statistics
 * snapshots. Note that callers must take care to sequence calls to <code>beginOperation</code>,
 * <code>ttfb</code>, <code>bytes</code>, <code>failOperation</code> and
 * <code>completeOperation</code> correctly. This implementation does not validate the correct
 * sequencing of these calls.
 */
public class Stats
{
   private final Map<OperationType, Counters> counters;
   private Map<OperationType, Counters> intervalCounters;

   // timers and intervalTimers assist in accounting for
   // Counter.ACTIVE_DURATION
   private final Map<OperationType, StatsTimer> timers;
   private Map<OperationType, StatsTimer> intervalTimers;

   private final long globalTimestamp;
   private long globalIntervalTimestamp;

   private final long initialObjectCount;
   private final long averageObjectSize;

   /**
    * Constructs a <code>Stats</code> instance with default <code>Counter</code> and
    * <code>StatsTimer</code> instances.
    * 
    * @param initialObjectCount
    *           the initial count of objects on the vault
    * @param averageObjectSize
    *           the average object size, in bytes
    * @throws IllegalArgumentException
    *            if initialObjectCount is negative
    * @throws IllegalArgumentException
    *            if averageObjectSize is negative
    */
   public Stats(final long initialObjectCount, final long averageObjectSize)
   {
      Validate.isTrue(initialObjectCount >= 0, "initialObjectCount must be >= 0 [%s]",
            initialObjectCount);
      Validate.isTrue(averageObjectSize >= 0, "averageObjectSize must be >= 0 [%s]",
            averageObjectSize);

      this.counters = new HashMap<OperationType, Counters>();
      this.intervalCounters = new HashMap<OperationType, Counters>();
      this.timers = new HashMap<OperationType, StatsTimer>();
      this.intervalTimers = new HashMap<OperationType, StatsTimer>();
      for (final OperationType o : OperationType.values())
      {
         this.counters.put(o, new Counters());
         this.intervalCounters.put(o, new Counters());
         this.timers.put(o, new StatsTimer());
         this.intervalTimers.put(o, new StatsTimer());
      }
      final long timestamp = System.nanoTime();
      this.globalTimestamp = timestamp;
      this.globalIntervalTimestamp = timestamp;
      this.initialObjectCount = initialObjectCount;
      this.averageObjectSize = averageObjectSize;
   }

   // Constructs a Stats instance using the specified Counters and StatsTimer maps.
   private Stats(
         final Map<OperationType, Counters> counters,
         final Map<OperationType, Counters> intervalCounters,
         final Map<OperationType, StatsTimer> timers,
         final Map<OperationType, StatsTimer> intervalTimers,
         final long globalTimestamp,
         final long globalIntervalTimestamp,
         final long initialObjectCount,
         final long averageObjectSize)
   {
      this.counters = counters;
      this.intervalCounters = intervalCounters;
      this.timers = timers;
      this.intervalTimers = intervalTimers;
      this.globalTimestamp = globalTimestamp;
      this.globalIntervalTimestamp = globalIntervalTimestamp;
      this.initialObjectCount = initialObjectCount;
      this.averageObjectSize = averageObjectSize;
   }

   /**
    * Sets the necessary counters for the upcoming operation
    * 
    * @param type
    *           the operation type of the current operation
    * @return the timestamp generated by this method, in nanoseconds. Used for all other methods
    *         that require a beginTimestamp
    * @throws NullPointerException
    *            if type is null
    * @throws IllegalArgumentException
    *            if type equals OperationType.ALL
    */
   public synchronized long beginOperation(final OperationType type)
   {
      validateOperationType(type);
      modAllCounter(type, Counter.COUNT, 1);
      final long op = modBothCounter(type, Counter.ACTIVE_COUNT, 1);
      final long all = modBothCounter(OperationType.ALL, Counter.ACTIVE_COUNT, 1);
      modAllActiveMinMaxCounter(type);
      final long beginTimestamp = System.nanoTime();

      // only start the timer if this is the only active operation of its type
      if (op == 1)
      {
         this.timers.get(type).startTimer(beginTimestamp);
         this.intervalTimers.get(type).startTimer(beginTimestamp);

         // only start the OperationType.ALL timer if this is also the only active
         // operation globally
         if (all == 1)
         {
            this.timers.get(OperationType.ALL).startTimer(beginTimestamp);
            this.intervalTimers.get(OperationType.ALL).startTimer(beginTimestamp);
         }
      }
      return beginTimestamp;
   }

   /**
    * Sets the necessary ttfb counters. This method is not required for operations that do not
    * record ttfb
    * 
    * @param type
    *           the operation type of the current operation
    * @param ttfb
    *           the time to first byte duration of the current operation, in nanoseconds
    * @throws NullPointerException
    *            if type is null
    * @throws IllegalArgumentException
    *            if type equals OperationType.ALL
    * @throws IllegalArgumentException
    *            if ttfb is negative
    */
   public synchronized void ttfb(final OperationType type, final long ttfb)
   {
      validateOperationType(type);
      Validate.isTrue(ttfb >= 0, "ttfb must be >= 0 [%s]", ttfb);
      modAllCounter(type, Counter.TTFB, ttfb);
   }

   /**
    * Sets the necessary bytes counters. This method is not required for operations that do not
    * record bytes. This method may be called multiple times per operation.
    * 
    * @param type
    *           the operation type of the current operation
    * @param bytes
    *           some number of bytes to set for the current operation
    * @throws NullPointerException
    *            if type is null
    * @throws IllegalArgumentException
    *            if type equals OperationType.ALL
    * @throws IllegalArgumentException
    *            if bytes is negative
    */
   public synchronized void bytes(final OperationType type, final long bytes)
   {
      validateOperationType(type);
      Validate.isTrue(bytes >= 0, "bytes must be >= 0 [%s]", bytes);
      modAllCounter(type, Counter.BYTES, bytes);
   }

   /**
    * Sets the necessary counters for an aborted operation.
    * 
    * @param type
    *           the operation type of the current operation
    * @param beginTimestamp
    *           the timestamp returned by <code>beginOperation</code>, in nanoseconds
    * @return the timestamp generated by calling this method, in nanoseconds
    * @throws NullPointerException
    *            if type is null
    * @throws IllegalArgumentException
    *            if type equals OperationType.ALL
    * @throws IllegalArgumentException
    *            if beginTimestamp is negative or greater than the timestamp generated by this
    *            method
    */
   public synchronized long abortOperation(final OperationType type, final long beginTimestamp)
   {
      return endOperation(type, Counter.ABORT_COUNT, beginTimestamp);
   }

   /**
    * Sets the necessary counters for a failed operation.
    * 
    * @param type
    *           the operation type of the current operation
    * @param beginTimestamp
    *           the timestamp returned by <code>beginOperation</code>, in nanoseconds
    * @return the timestamp generated by calling this method, in nanoseconds
    * @throws NullPointerException
    *            if type is null
    * @throws IllegalArgumentException
    *            if type equals OperationType.ALL
    * @throws IllegalArgumentException
    *            if beginTimestamp is negative or greater than the timestamp generated by this
    *            method
    */
   public synchronized long failOperation(final OperationType type, final long beginTimestamp)
   {
      return endOperation(type, Counter.FAILURE_COUNT, beginTimestamp);
   }

   /**
    * @param type
    *           the operation type of the current operation
    * @param beginTimestamp
    *           the timestamp returned by <code>beginOperation</code>, in nanoseconds
    * @return the timestamp generated by calling this method, in nanoseconds
    * @throws NullPointerException
    *            if type is null
    * @throws IllegalArgumentException
    *            if type equals OperationType.ALL
    * @throws IllegalArgumentException
    *            if beginTimestamp is negative or greater than the timestamp generated by this
    *            method
    */
   public synchronized long completeOperation(final OperationType type, final long beginTimestamp)
   {
      return endOperation(type, Counter.COMPLETE_COUNT, beginTimestamp);
   }

   // Called by failOperation and completeOperation
   private long endOperation(
         final OperationType type,
         final Counter endCounter,
         final long beginTimestamp)
   {
      final long endTimestamp = System.nanoTime();
      validateOperationType(type);
      Validate.isTrue(beginTimestamp >= 0, "beginTimestamp must be >= 0 [%s]", beginTimestamp);
      Validate.isTrue(beginTimestamp <= endTimestamp,
            "beginTimestamp must be <= endTimestamp");

      final long duration = endTimestamp - beginTimestamp;

      modAllCounter(type, endCounter, 1);
      modAllCounter(type, Counter.DURATION, duration);

      final long op = modBothCounter(type, Counter.ACTIVE_COUNT, -1);
      final long all = modBothCounter(OperationType.ALL, Counter.ACTIVE_COUNT, -1);
      modAllActiveMinMaxCounter(type);

      // only stop timers and update ACTIVE_DURATION if this is the last active operation of its
      // type
      if (op == 0)
      {
         final long opDuration = this.timers.get(type).stopTimer(endTimestamp);
         final long opIDuration = this.intervalTimers.get(type).stopTimer(endTimestamp);
         modCounter(type, Counter.ACTIVE_DURATION, opDuration);
         modICounter(type, Counter.ACTIVE_DURATION, opIDuration);

         // only stop the OperationType.ALL timer and update ACTIVE_DURATION if this operation is
         // also the last active operation globally
         if (all == 0)
         {
            final long allDuration = this.timers.get(OperationType.ALL).stopTimer(endTimestamp);
            final long allIDuration =
                  this.intervalTimers.get(OperationType.ALL).stopTimer(endTimestamp);
            modCounter(OperationType.ALL, Counter.ACTIVE_DURATION, allDuration);
            modICounter(OperationType.ALL, Counter.ACTIVE_DURATION, allIDuration);
         }
      }
      return endTimestamp;
   }

   // Convenience method for validating OperationType
   private void validateOperationType(final OperationType type)
   {
      Validate.notNull(type, "type must not be null");
      Validate.isTrue(!type.equals(OperationType.ALL), "type must not be OperationType.ALL");
   }

   /**
    * Constructs a <code>Stats</code> instance containing copies of all counters and timers stored
    * by this instance. All counters and timers of the returned instance are independent of those
    * found in this instance.
    * 
    * @return a duplicate <code>Stats</code> instance
    */
   public synchronized Stats snapshot()
   {
      final Map<OperationType, Counters> newIntCtrs = new HashMap<OperationType, Counters>();
      final Map<OperationType, Counters> copyCtrs = new HashMap<OperationType, Counters>();
      final Map<OperationType, StatsTimer> newIntTimers = new HashMap<OperationType, StatsTimer>();
      final Map<OperationType, StatsTimer> copyTimers = new HashMap<OperationType, StatsTimer>();

      final long snapshotTimestamp = System.nanoTime();
      for (final OperationType o : OperationType.values())
      {
         newIntCtrs.put(o, new Counters());
         // must persist the current state of active operations across snapshots
         newIntCtrs.get(o).setCounter(Counter.ACTIVE_COUNT,
               this.intervalCounters.get(o).getCounter(Counter.ACTIVE_COUNT));
         newIntCtrs.get(o).setCounter(Counter.ACTIVE_COUNT_MIN,
               this.intervalCounters.get(o).getCounter(Counter.ACTIVE_COUNT));
         newIntCtrs.get(o).setCounter(Counter.ACTIVE_COUNT_MAX,
               this.intervalCounters.get(o).getCounter(Counter.ACTIVE_COUNT));

         copyCtrs.put(o, new Counters(this.counters.get(o)));
         final StatsTimer s = new StatsTimer();
         // timers in the new interval must not have a start timestamp previous
         // to the creation of the interval so that ACTIVE_DURATION calculations
         // remain accurate
         s.startTimer(snapshotTimestamp);
         newIntTimers.put(o, s);
         copyTimers.put(o, new StatsTimer(this.timers.get(o)));
      }

      final Stats snapshot =
            new Stats(copyCtrs, this.intervalCounters, copyTimers, this.intervalTimers,
                  this.globalTimestamp, this.globalIntervalTimestamp, this.initialObjectCount,
                  this.averageObjectSize);
      this.intervalCounters = newIntCtrs;
      this.intervalTimers = newIntTimers;
      this.globalIntervalTimestamp = snapshotTimestamp;
      return snapshot;
   }

   /**
    * Gets the value of the specified counter, for the specified operation type.
    * 
    * @param type
    *           the operation type to retrieve the counter value for
    * @param counter
    *           the counter type to retrieve the value for
    * @param interval
    *           if true retrieve the counter for this interval, else the overall counter
    * @return the value of the given counter
    * @throws NullPointerException
    *            if type is null
    * @throws NullPointerException
    *            if counter is null
    */
   public synchronized long getCounter(
         final OperationType type,
         final Counter counter,
         final boolean interval)
   {
      Validate.notNull(type, "type must not be null");
      Validate.notNull(counter, "counter must not be null");
      if (interval)
         return this.intervalCounters.get(type).getCounter(counter);
      return this.counters.get(type).getCounter(counter);
   }

   /**
    * Calculates and returns the value of the specified stat, for the specified operation type.
    * 
    * @param type
    *           the operation type to retrieve the counter value for
    * @param stat
    *           the stat type to calculate the value for
    * @param interval
    *           if true retrieve the stat for this interval, else the overall stat
    * @return the calculated value of the given stat
    * @throws NullPointerException
    *            if type is null
    * @throws NullPointerException
    *            if stat is null
    */
   public synchronized double getStat(
         final OperationType type,
         final Stat stat,
         final boolean interval)
   {
      Validate.notNull(type, "type must not be null");
      Validate.notNull(stat, "stat must not be null");
      if (interval)
         return getStat(this.intervalCounters.get(type), stat, this.globalIntervalTimestamp);
      return getStat(this.counters.get(type), stat, this.globalTimestamp);
   }

   // Called by getStat and getIntervalStat
   private double getStat(final Counters ctrs, final Stat stat, final long timestamp)
   {
      switch (stat)
      {
         case THROUGHPUT :
            return avg(ctrs.getCounter(Counter.BYTES), ctrs.getCounter(Counter.DURATION));
         case ACTIVE_THROUGHPUT :
            return avg(ctrs.getCounter(Counter.BYTES), ctrs.getCounter(Counter.ACTIVE_DURATION));
         case ELAPSED_THROUGHPUT :
            return avg(ctrs.getCounter(Counter.BYTES), System.nanoTime() - timestamp);
         case DURATION_AVG :
            return avg(ctrs.getCounter(Counter.DURATION), ctrs.getCounter(Counter.COUNT));
         case BYTES_AVG :
            return avg(ctrs.getCounter(Counter.BYTES), ctrs.getCounter(Counter.COUNT));
         case TTFB_AVG :
            return avg(ctrs.getCounter(Counter.TTFB), ctrs.getCounter(Counter.COUNT));
         case RATE :
            return avg(ctrs.getCounter(Counter.COUNT), System.nanoTime() - timestamp);
      }
      return 0.0;
   }

   /**
    * Calculates elapsed time since the creation of this instances, in nanoseconds.
    * 
    * @param interval
    *           if true retrieve the duration for this interval, else the overall duration
    * @return elapsed time, in nanoseconds
    */
   public synchronized long getDuration(final boolean interval)
   {
      if (interval)
         return System.nanoTime() - this.globalIntervalTimestamp;
      return System.nanoTime() - this.globalTimestamp;
   }

   /**
    * Calculates a rough approximation of vault fill. Lack of knowledge of object size for deleted
    * objects as well as vault activity by other clients limits the accuracy of this approximation.
    * 
    * @return vault fill, in bytes
    */
   public synchronized long getVaultFill()
   {
      final long bytesWritten = getCounter(OperationType.WRITE, Counter.BYTES, false);
      final long objectsDeleted = getCounter(OperationType.DELETE, Counter.COMPLETE_COUNT, false);

      return (this.initialObjectCount * this.averageObjectSize) + bytesWritten
            - (objectsDeleted * this.averageObjectSize);
   }

   private double avg(final long sum, final long count)
   {
      if (count > 0)
         return (double) sum / count;
      return 0.0;
   }

   private long modCounter(final OperationType o, final Counter c, final long amt)
   {
      final long counter = this.counters.get(o).getCounter(c);
      final long newValue = counter + amt;
      this.counters.get(o).setCounter(c, newValue);
      return newValue;
   }

   private long modICounter(final OperationType o, final Counter c, final long amt)
   {
      final long counter = this.intervalCounters.get(o).getCounter(c);
      final long newValue = counter + amt;
      this.intervalCounters.get(o).setCounter(c, newValue);
      return newValue;
   }

   private long modBothCounter(final OperationType o, final Counter c, final long amt)
   {
      modCounter(o, c, amt);
      return modICounter(o, c, amt);
   }

   private void modAllCounter(final OperationType o, final Counter c, final long amt)
   {
      modCounter(o, c, amt);
      modICounter(o, c, amt);
      modCounter(OperationType.ALL, c, amt);
      modICounter(OperationType.ALL, c, amt);
   }

   private void modActiveMinMaxCounter(final Counters ctrs)
   {
      final long active = ctrs.getCounter(Counter.ACTIVE_COUNT);
      final long activeMin = ctrs.getCounter(Counter.ACTIVE_COUNT_MIN);
      final long activeMax = ctrs.getCounter(Counter.ACTIVE_COUNT_MAX);

      if (active < activeMin)
         ctrs.setCounter(Counter.ACTIVE_COUNT_MIN, active);
      if (active > activeMax)
         ctrs.setCounter(Counter.ACTIVE_COUNT_MAX, active);
   }

   private void modAllActiveMinMaxCounter(final OperationType o)
   {
      modActiveMinMaxCounter(this.counters.get(o));
      modActiveMinMaxCounter(this.intervalCounters.get(o));
      modActiveMinMaxCounter(this.counters.get(OperationType.ALL));
      modActiveMinMaxCounter(this.intervalCounters.get(OperationType.ALL));
   }
}
